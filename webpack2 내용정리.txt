그런트 2011년 후반기
2013년 2월 인기

걸프
2013년 여름

Globals + Namespace

AMD

CommonJS

UMD(Universal Module Definition)

ES6



자바 스크립트 개발이 점점 복잡 해짐에 따라 의존성 관리가 번거로울 수 있습니다. 리팩토링은 또한 손상되었습니다 :로드 체인의 올바른 순서를 유지하기 위해 더 새로운 의존성을 어디에 두어야합니까?

자바 스크립트 모듈 시스템은 이러한 문제 및 다른 문제를 처리하려고 시도합니다. 그들은 점점 커지는 자바 스크립트 환경을 수용하기 위해 태어났습니다. 다양한 솔루션으로 무엇을 얻을 수 있는지 봅시다.



뷰js튜토리얼
http://tutorialzine.com/tag/vue-js/
http://meetup.toast.com/posts/99

scss 강좌
https://velopert.com/1712



노드 설명
http://webframeworks.kr/tutorials/nodejs/api-server-by-nodejs-01/

노드는 주로 웹서버와 같은 네트웍 프로그램을 위해 고안된 환경이지만
 최근에는 웹 개발 환경의 빌드 툴로도 많이 사용되고 있습니다.

리엑트에서 사용하는 웹팩(Webpack),
스트림 형식의 빌드툴 굴프(Gulp), 그리고 설정 방식의 빌트 툴인 그런트(Grunt)가 모두 노드 환경에서 개발된 도구입니다.

노드 환경으로 인해 그 동안 웹 브라우져에서만 사용하는 자바스크립트를 어디서나 사용할 수 있게 되었습니다.



Grunt/Gulp
테스크러너는 프론트엔드의 다양하게 발생하는 귀차니즘을 해결해주는 자동화 도구
Gulp와 Grunt가 양대산맥이지만, 할 수 있는 것은 큰차이가 없다


Grunt
동기화 프로세스(작업 1개가 1개의 순서로 실행)으로 속도가 느림
(비동기적으로 처리하는 플러그인도 있음)

Gulp는 1개 작업이 1개의 순서를 컴팩트하게 사용가능하며
작업을 동시에 할 수 있는 특징


모듈 관리
Browserify와 Webpack내용은 테스크러나와 마찬가지로 큰 차이점 없다
Webpack이 후발주자로 최근 새 프로젝트에서 적용사례가 많아지고 있습니다.

Browserify는 하나의 JS파일을 출력하는 반면,
Browserify는 Gulp등과 같이 사용하는 것이 일반적이지만,
Webpack은 여러개의 JS를 출력하는 것이 쉽고
Webpack은 그것이 없어도 풀스택에서 빌드할 수 있

코드킷Codekit <> 유료프로그램
오토 리로드 브라우져

bower 보어 바우어
트위터에서 만든 프론트 엔드의 패키지를 관리해주는 도구

출처: http://web-front-end.tistory.com/4 [프로그래밍 요람에서 무덤까지]

“프론트엔드 웹개발자, 자동화 기술 써보세요”

Browserify.JS(브라우져리파이)
common.js 모듈러 패턴을 사용할 수 있게 해 주는 broweserify 툴


웹팩이란 무엇입니까?
간단히 말해서, webpack은 자바 스크립트를위한 모듈 번들러입니다.
그러나 출시 이후 의도적으로 또는 커뮤니티의 의지에 따라 모든 프런트 엔드 코드의 관리자로 발전했습니다.

    module.exports = {
        entry: {
            app: '',
        },
        output: {
            path: '',
            filename: '',
            publicPath: '',
        },
        module: {

        },
        plugins: []
    };


최종 빌드를 위해 번들로 제공

참고 사이트
https://kygolife.com/
http://gooqx.com/

https://webpack.js.org/

불필요 폴더 숨김
VScode F1 workspace Setting
excluding


Extension
Open in Browser - TechER
Mithril Emmet



번들러 끝판왕 웹팩
그림처럼 여러 파일들을 하나로 합쳐줍니다.
JS가 점점 중요해지면서 JS 자체만으로도 엄청난 의존 관계가 생겼습니다.









 모듈을 정의하는 방법

 주된 것은 CommonJS, AMD, ES6 내장 모듈이다.
 CommonJS 는 동기적으로 서버측에 접근한다.
 반대로, AMD(Asynchronous Module Definition) 는 모듈을 정의하고 로드하는 것을 비동기적으로, 중단없이(non-blocking) 수행한다.

 CommonJS 와 AMD 는 JavaScript 가 내부적으로 모듈과 의존성에 대한 지원을 하지 않는 상태에서 만들어졌다.

ES6 에서는 언어 내부적으로 JavaScript 모듈 로드를 지원하며,
CommonJS 와 AMD 의 방식 모두를 지원한다.
결국, 모듈은 언어의 일부가 되었다.

작업에서 3가지 방식을 골고루 사용할 수 있다.
새 프로젝트에서 ES6 모듈 방식을 사용할 것을 권한다.
webpack 과 같은 빌드 툴이 여러 가지 방식으로 구현되어 있는 프로젝트를 로드하는 데에 도움이 될 수 있다.



Browserify / Webpack / RequireJS – 디펜던시 번들러

이들은 어플리케이션에 필요한 모든 디펜던시를 한곳에서 정의하고 나중에서 필요한 부분에서 필요한 디펜던시만 불러서 사용할 수 있도록 해준다.

자바스크립트 어플리케이션을 모듈 단위로 개발 가능하게 해주는 중요한 역할을 하는 프레임웍들이다.

 프론트엔드에서는 처리하는 일들이 점점 많아지고 있고 따라서 프론트엔드 구조 또한 많이 복잡해지고 정교해 지고 있다.

 그리고 그렇게 복잡해지고 있는 프론트엔드 개발에 맞춰 자동화 시스템도 동시에 점점 복잡 다양해 지고 있다.

웹 개발의 일부가 되어 애플리케이션마다 반복적으로 수행될 것이다. 이런 일련의 작업들을 자동화 하기 위해

태스크 러너(이하 task runner)
LESS 또는 SASS 파일을 CSS로 컴파일하기
CoffeeScript 또는 TypeScript를 자바스크립트 파일로 컴파일 하기
자바스크립트 파일들을 묶고(bundle) 축소(minify)하기
자바스크립트가 코딩 규칙을 따르는지 JSHint 툴로 검사하기

https://terakoya.site/dev/visual-studio-code-recommend-plugin/

페이지 개발에 사용되는 각 JavaScript 의존성을 포함하기 위해, script 를 늘어 쓰는 것은 느린 방법이다.

 게다가, 대부분의 사이트는 JavaScript 번들링(역주 : 패키징)을 사용한다. 번들링 과정은 모든 의존성을 관리하며 당신의 프로젝트를 다시 "번들링" 하는 데에 사용될 수 있다. 부가적으로, 어떤 개발자들은 기능의 변화 없이 불필요한 문자를 생략하는 minifying 과정을 사용할 수 있다. 이 과정은 클라이언트가 다운받아야 하는 데이터의 양을 줄여준다.
 어떤 툴은 hot reloading 과 같은 기능을 제공한다. 이 기능은 당신이 파일이나 소스맵을 저장했을 때 당신의 브라우저에 적용사항을 바로 업데이트 하는 기능이다. 소스맵은 번들링된 JavaScript 파일을 디버깅하기 편하게 원래의 파일과 매칭시키는 기능이다.
 방금 설명한 내용은 본질적으로 빌드 과정이다. 대부분의 JavaScript 개발자들이 이것에 대해 이야기하지는 않지만 코드는 배포직전의 단계로 컴파일할 수 있다. "프론트엔드 개발/운영" 이나 빌드, 배포를 관리하는 과정에서 (코드 관리에 대한) 노력이 점점 더 필요하다.


GULP는 “빌드 자동화 툴” 입니다. 그 말은 즉슨, 위의 작업들은 gulp가 없어도 할 수 있는 것 들입니다. (예를 들어, 저번 강좌에서 사용했던 플러그인인 gulp-uglify, gulp-clean-css, gulp-htmlmin, gulp-imagemin 은, NPM에 따로 의존 모듈인 uglify-js, clean-css, htmlmin, imagemin이 있습니다) 단, 여러가지 작업을 일일히 하기엔 번거롭고, 빌드 코드를 따로 작성해도 되지만, 이를 더 편하게 작성하기 위하여 gulp가 사용되는 것이랍니다.


 말했던 것 같이, webpack 설정은 webpack 이 다음과 같은 동작을 하도록 한다.
시작 지점으로 app.js 를 사용한다.
.js 로 끝나는 모든 파일을 처리한다.
파일의 변환 방식으로 ES6 를 변환하는 babel-loader 를 사용하며, react 를 위해 JSX 를 사용한다.
모든 JavaScript 파일은 번들링해서 static/bundle.js 파일로 묶는다.




JSHint / JSLint / ESLint – 신텍스 린트 유틸리티

Syntax 경고 및 에러를 알려주는 툴. 예를 들어, 따옴표가 안닫혔다던지 괄호가 빠졌다던지 혹은 세미콜론이 없다던지 등등 코딩 중 쉽게 발생할 수 있는 문법적 오류를 콕 집어주는 툴이다. 원하는 법칙에 맞게 설정을 바꿔서 사용할 수도 있다. 특히 Gulp나 Grunt등의 자동화 툴과 연동해서 파일 수정 후 저장할 때 마다 린트가 실행되도록 하면 실시간으로 문법 오류를 수정할 수 있어 코드의 질을 높이는데 큰 도움이 된다.

Babel – 트렌스파일러

ES2015가 이미 표준화 된 상태이고 ES2016도 현재 표준화 작업 중이다. 따라서 여전히 새로운 표준을 지원하지 않는 브라우저가 있다는 이유로 새로운 신텍스를 사용하지 않을 이유는 없다. 특히 Babel등과 같은 훌륭한 트렌스파일러가 있다면 더더욱 새로운 신텍스를 익힐 필요가 있다고 생각 한다. 나도 아직 많이 사용해 보진 않았지만 특히 화살표 함수와 promise, then 등과 같은 비동기 관련 함수들만 잠시 사용해봐도 많이 편리해진 것을 알 수 있다.


자동화 툴
Gulp / Grunt – 테스크 러너(Task runner)

앞서 언급될 각종 개발 관련 Helper들을 자동으로 실행시켜 주는 테스크 러너이다. 예를들어, 파일 수정후 저장을 할 때마다 브라우져 페이지 새로고침, 신텍스 린트 테스트 등을 실시간 자동으로 실행해 주며, 빌드작업에 포함되는 각종 테스트 및 트렌스파일링, 파일 최소화 작업 등을 모아 한 두개의 간단한 명령으로 자동화 할 수 있다. 게다가 아주 기본적인 서버도 포함하고 있어서 간단한 테스트용 어플리케이션을 빠른 속도로 셋업하는데도 큰 편리를 제공해 준다. 결론적으로 개발 과정에서 불가피하게 끊임없이 반복되는 여러가지 작업들을 자동화 시켜 줌으로써 귀차니즘 극복에 극적인 공헌을 하는 일등 공신이다.



태스크매니저가 하는 일들
Transpile,
Concatenate,
Minify,
Lint,
Template process,
Image sprite generate,
Upload,
Purge,
Test,

그 밖에도..
실시간 리로딩
HMR(Hot module
replacement)
실시간 트랜스파일