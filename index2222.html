<!doctype html>
<html lang="en">

    <head>
        <meta charset="utf-8">
        <title>Webpack - The Module Bundler</title>
        <meta name="description" content="A framework for easily creating beautiful presentations using HTML">
        <meta name="author" content="Hakim El Hattab">
        <meta name="apple-mobile-web-app-capable" content="yes" />
        <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
        <link rel="stylesheet" href="css/reveal.css">
        <link rel="stylesheet" href="css/theme/league.css" id="theme">
        <!-- <link rel="stylesheet" href="css/theme/ember.css" id="theme"> -->
        <!-- Code syntax highlighting -->
        <!-- <link rel="stylesheet" href="lib/css/monokai_sublime.css"> -->
        <!-- <link rel="stylesheet" href="https://highlightjs.org/static/demo/styles/atom-one-dark.css"> -->
        <!-- <link rel="stylesheet" href="https://highlightjs.org/static/demo/styles/monokai-sublime.css"> -->
        <!--<link rel="stylesheet" href="https://highlightjs.org/static/demo/styles/monokai.css">       -->
        <link rel="stylesheet" href="https://highlightjs.org/static/demo/styles/atom-one-dark.css">
        <link rel="stylesheet" href="https://code.cdn.mozilla.net/fonts/fira.css">
        <link rel='stylesheet' href='lib/font/devicons/devicons.css'>
        <style type="text/css">
        .reveal{font-size:24px}
        .txl{text-align:left;display:inline-block}
        .devicons-javascript{color:#f5de19}
        .devicons-html5{color:#e44f26}
        .devicons-css3{color:#1572b6}
        .devicons-npm{color:#a23332}
        .devicons-sass{color:#cd6799}
        </style>
        <!-- Printing and PDF exports -->
        <script>
            var link = document.createElement( 'link' );
            link.rel = 'stylesheet';
            link.type = 'text/css';
            link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
            document.getElementsByTagName( 'head' )[0].appendChild( link );
        </script>
        <!--[if lt IE 9]>
        <script src="lib/js/html5shiv.js"></script>
        <![endif]-->
    </head>

    <body>
        <div class="reveal">
            <!-- Any section element inside of this container is displayed as a slide -->
            <div class="slides">
                <section>
                    <img src="img/logo-on-dark-bg.png " alt="" style="width:50%">
                    <p style="margin:-30px 0 120px 0">-프론트엔드 웹 개발환경 셋팅-</p>
                    <p>2017. 7. 19.</p>
                    <p>IT 개발2팀 UI파트 - 김재호</p>
                </section>

                <section>
                    <h2>The Agenda</h2>
                    <ul>
                        <li>Javascript 모듈의 필요성</li>
                        <li>webpack 소개</li>
                        <li>webpack 설치 가이드</li>
                        <li>webpack 사용방법 (번들링)</li>
                        <li>webpack 설정</li>
                    </ul>
                </section>


                <section>
                    <section>
                        <h2>Javascript 모듈의 필요성</h2>
                    </section>


                    <section>
                        <h2>Javascript의 문제점</h2>
                        <ul>
                            <li>글로벌(전역) 스코프가 쉽게 오염</li>
                            <li>동일한 이름을 가진 변수 사용 (이름 충돌 문제)</li>
                            <li>올바른 의존성 순서</li>
                            <li>웹페이지가 커질수록 script 태그 수 의 증가</li>
                        </ul>

                        <pre><em class="file_name"><i class="devicons devicons-html5"></i>&nbsp;index.html</em><code class="html">
    &lt;script src="../js/lib/jquery.min.js"&gt;&lt;/script&gt;
    &lt;script src="../js/lib/bootstrap.min.js"&gt;&lt;/script&gt;
    &lt;script src="../js/app.js"&gt;&lt;/script&gt;
    &lt;script&gt;
        $(function() {
            //암묵적 전역
            //var 키워드 생략 시 전역변수로 인식
            foo = '';
        });
    &lt;/script&gt;
                        </code></pre>
                    </section>

                    <section>
                        <h2>Javascript 전역 문제 해결 방법</h2>
                        <pre><code class="javascript">
    //IIFE (Immediately Invoked Founction Expression)
    (function() {
        /* code here */
    })();
                        </code></pre>

                        <pre><code class="javascript">
    //'App' 같은 하나의 전역객체 밑에 네임스페이스를 갖습니다.
    var App = App || {};
    App.Models = {};
    App.Models.Note = function() {};
                        </code></pre>
                    </section>


                    <section>
                        <h2>Javascript 의존성 관리</h2>
                        <p>코드베이스가 커지면 유지보수가 쉽도록 코드를 나누어 관리하는 모듈 시스템이 필요</p>
                         <ul>
                            <li>CommonJS (서버 사이드)</li>
                            <li>AMD (클라이언트)</li>
                        </ul>
                    </section>


                    <section>
                        <h2>CommonJS</h2>
                         <ul>
                            <li>JS의 활용성을 높이려는 자발적 워킹그룹</li>
                            <li>JS를 범용 프로그래밍 언어로 만드는 것이 목적</li>
                            <li>JS 모듈 관리에 관한 코딩 표준을 제시함</li>
                        </ul>

						<pre><code class="javascript">
	var lib = require( "package/lib" );

	function foo() {
	    lib.log( "hello world!" );
	}

	module.exports = foo;
						</code></pre>
                    </section>


                    <section>
                        <h2>AMD (Asynchronouse Module Definition)</h2>
                         <ul>
                            <li>브라우저에서의 JS 모듈 활용성을 높일 목적으로 CommonJS에서 파생됨</li>
                            <li>jQuery를 비롯 다수의 오픈소스 솔루션이 AMD를 지지</li>
                            <li>AMD 표준을 준수하는 가장 대표적인 RequierJS</li>
                            <li>CommonJS와 마찬가지로 JS 모듈 관리에 관한 코딩 표준을 제시함</li>
                        </ul>

						<pre><code class="javascript">
	define(["package/lib"], function (lib) {
	    function foo() {
	        lib.log( "hello world!" );
	    }
	    return {
	        foobar: foo
	    }
	});

	require(["package/myModule"], function(myModule) {
	    myModule.foobar();
	});
						</code></pre>

                    </section>


                    <section>
                        <h2>UMD (Universal Module Definition)</h2>
                        <p>AMD + CommonJS + IIFE 를 모두 지원하는 모듈</p>

						<pre><code class="javascript">
	(function (root, factory) {
	    if (typeof define === 'function' &amp;&amp; define.amd) {
	        //AMD
	        define(['jquery'], factory);
	    } else if (typeof exports === 'object') {
	        //Node, CommonJS-like
	        module.exports = factory(require('jquery'));
	    } else {
	        //Browser globals (root is window)
	        root.returnExports = factory(root.jQuery);
	    }
	}(this, function ($) {
	    //methods
	    function myFunc(){};
	    //exposed public method
	    return myFunc;
	}));
						</code></pre>
                    </section>


                    <section>
                        <h2>모듈 시스템의 도입</h2>
                        <img src="img/es6.png" alt="" width="400">
                        <p>ES6 스펙부터 언어자체적으로 가능한 모듈 시스템을 도입</p>
                    </section>


                    <section>
                        <h2>ES6 - Modules</h2>
                        <ul>
                            <li>export 모듈 선언 / import 모듈 사용</li>
                            <li>전역변수 오염없이 모듈을 선언하고 사용할 수 있도록 지원</li>
                            <li>자주 사용되는 코드를 필요할 때마다 재사용</li>
                        </ul>

                     	<pre><code class="javascript">
	import lib from 'package/lib';

	export function foo() {
	    return lib.log( "hello world!" );
	}
                        </code></pre>
                    </section>


                     <section>
                     	<h2>하지만..</h2>
                        <p>안타깝게도 ES6가 2015년에 나온지 2년이 지난 지금 브라우저내에서<br>import, export는 아직 구현되지 않은 기능입니다.</p>
                        <a href="http://caniuse.com/#feat=es6-module" target="_blank">ES6 - Module 브라우저 지원 상황</a>
                    </section>

                     <section>
                     	<h2>모듈 번들러란? (Browserify, webpack)</h2>

                     	<img src="img/cover-1.jpg" width="500">
                     	<p>브라우저에서 아직 지원이 되지 않는 모듈을<br>사용 할 수 있도록 하는것이 모듈 번들러의 주요 기능</p>

                        <aside class="notes">
						https://blog.qmo.io/javascript-tooling-the-evolution-and-future-of-js-front-end-build-tools/
                        </aside>
                    </section>

                </section>




                <section>
                    <section>
                        <h2>webpack 소개</h2>
                    </section>

                    <section>
                        <h2></h2>
                        <img src="https://cdn.filepicker.io/api/file/QIuZVivBTFWIu8LN9i3E" alt="">
						그림 1. 모듈 번들러 웹팩

                        <p>번들러 끝판왕 웹팩
                         그림처럼 여러 파일들을 하나로 합쳐줍니다.
                            JS가 점점 중요해지면서 JS 자체만으로도 엄청난 <strong>의존 관계</strong>가 생겼습니다.</p>
                        <p>ES6 모듈, RequireJS, CommonJS같은 JS 모듈 시스템들이 나오면서 JS 파일도 다른 프로그래밍 언어처럼 모듈 개념이 생겼습니다. import나 require로 js끼리 서로 의존합니다. 특히 노드로 만들다 보면 모듈이 기본 수 백개에서 많게는 수 만개까지 갑니다. 이런 것을 하나의 JS로 합쳐주는 거죠.</p>
                    </section>

                </section>




                <section>
                    <section>
                    	<h2>webpack 설치 가이드</h2>
                   	</section>

                    <section>
                        <h2>Node.js 설치</h2>
                       	<div style="margin:80px 0">
							<img style="display:inline-block;vertical-align:middle;margin:0" width="200" alt="" src="img/nodejs.png">
							<img style="display:inline-block;vertical-align:middle;margin:0 30px" width="20" alt="" src="img/plus.png">
							<img style="display:inline-block;vertical-align:middle;margin:0" width="150" alt="" src="img/npm.png">
						</div>

                        <p>webpack을 사용하기 위해선 Node.js가 필수로 설치 되어 있어야 합니다.<br>아래 사이트를 방문하여 OS에 맞는 버전으로 설치합니다.</p>
                        <ul>
                        	<li><a href="http://d2.naver.com/helloworld/4994500](http://d2.naver.com/helloworld/4994500" target="_blank" title="Node.js">Node.js 소개</a></li>
                        	<li><a href="https://nodejs.org/ko/](https://nodejs.org/ko/">Node.js 다운로드</a></li>
                        </ul>
                    </section>


                    <section>
                        <h2>디렉터리 구조</h2>
                        <pre><code class="bash">
	[webpack2-demo]
	├── dist                            # output 디렉토리, 프로덕션 환경 배포 파일
	├── node_modules          # npm package들이 설치된 디렉토리
	├── src
	│   ├── app.js
	│   └── app.css
	├── index.html
	├── package.json             # 프로젝트 구성 정보
	└── webpack.config.js      # 웹팩 설정 파일
                        </code></pre>
                    </section>


                    <section>
                        <h2>프로젝트 초기화</h2>
                        <p>커맨드를 실행 후, 프로젝트 폴더로 이동해서 Node.js 프로젝트를 생성합니다.<br>package.json 파일이 생성됩니다.</p>

                        <pre><code class="bash">
	$ npm init
                        </code></pre>
                    </section>


                    <section>
                        <h2>잠깐 살펴보는 리눅스, npm 명령어</h2>

                        <pre><code class="bash">
	$ mkdir [folderName]                 # 디렉토리 생성
	$ touch [fileName]                      # 파일 생성
	$ npm init -y                               # 입력 생략
	$ npm i jquery                            # i  === install
	$ npm i -S jquery                        # -S === --save
	$ npm i -D jquery                        # -D === --save-dev
	$ npm un -D jquery                     # un === uninstall

	# Node.js Path API

	# 현재 파일 경로
	__filename;                                  # D:\workspace\diagram\main.js
	# 현재 디렉토리
	__dirname;                                   # D:\workspace\diagram
	# 경로 연결
	path.join(__dirname, '/test')       # /home/dirname/test
	# 상대적인 경로로 연결
	path.resolve('/foo/bar', './baz')   # /foo/bar/baz
                        </code></pre>
                    </section>

                    <section>
                        <h2>webpack 설치</h2>
						<p>webpack CLI 팩키지는 가능한 로컬에 설치해서 상대 경로를 사용하거나<br>npm 스크립트로 팩키지를 실행하는 것이 좋습니다.</p>

                        <pre><code class="bash">
	# 전역 설치
	$ npm install webpack -g

	# 로컬 설치
	$ npm install webpack --save-dev
                        </code></pre>
                    </section>

                </section>




				<section>

					<section>
                    	<h2>webpack 사용방법 (번들링)</h2>
                   	</section>


                    <section>
                        <h2>빌드된 코드를 로드할 html 파일</h2>
                        <pre><em class="file_name"><i class="devicons devicons-html5"></i>&nbsp;index.html</em><code class="html">
    &lt;html&gt;
        &lt;head&gt;
            &lt;meta charset="utf-8"&gt;
        &lt;/head&gt;
        &lt;body&gt;
            &lt;h1&gt;Hello Webpack&lt;/h1&gt;
            &lt;script type="text/javascript" src="dist/app.bundle.js"&gt;&lt;/script&gt;
        &lt;/body&gt;
    &lt;/html&gt;
                        </code></pre>
                    </section>


                    <section>
                        <h2>번들 파일 생성 (app.bundle.js)</h2>
                        <p>다음과 같이 명령어를 실행하여 모듈을 컴파일할 수 있습니다.</p>

						<pre><em class="file_name"><i class="devicons devicons-javascript"></i>&nbsp;app.js</em><code class="javascript">
	console.log('Hello Webpack');
                        </code></pre>

                        <pre><code class="bash">
	# webpack {엔트리 파일 경로} {번들 파일 경로}
	$ webpack ./src/app.js ./dist/app.bundle.js
                        </code></pre>
                    </section>


                    <section>
                        <h2>ES6 - module 사용해 보기</h2>

						<pre><em class="file_name"><i class="devicons devicons-javascript"></i>&nbsp;hello.js</em><code class="javascript">
	export default function hello() {
	    console.log('Hello Webpack!!!!');
	}
                        </code></pre>

                        <pre><em class="file_name"><i class="devicons devicons-javascript"></i>&nbsp;app.js</em><code class="javascript">
	import hello from './hello'
	hello();
	//console.log('Hello Webpack');
                        </code></pre>
                    </section>


                    <section>
                        <h2>watch 모드</h2>
                        <p>소스코드가 변경될 때마다 자동으로 감지해서 다시 번드링 해주는 기능<br>개발중에는 주로 watch 모드를 이용</p>

                        <pre><code class="bash">
	# 엔트리 파일 변경시 자동 리빌드
	$ webpack ./src/app.js ./dist/app.bundle.js --watch
	or
	$ webpack ./src/app.js ./dist/app.bundle.js -w
                        </code></pre>
                    </section>


                    <section>
                        <h2>코드 압축 기능</h2>

                        <pre><code class="bash">
	# minified code
	$ webpack ./src/app.js ./dist/app.bundle.js -p
                        </code></pre>
                    </section>

				</section>



				<section>

					<section>
                    	<h2>webpack 설정</h2>
                   	</section>


                    <section>
                        <h2>webpack의 기본적인 4가지 컨셉</h2>
                        <ul>
                        	<li>Entry: 웹팩이 파일을 읽어들이기 시작하는 부분을 설정</li>
                        	<li>Output: 결과물이 어떻게 나올지 설정</li>
                        	<li>Module: 웹팩을 통해 번들링을 진행할 때 처리해야 하는 태스크들을 실행</li>
                        	<li>Plugins: 확장기능</li>
                        </ul>
                    </section>


                    <section>
                        <h2>webpack 설정 파일</h2>
                        <pre><code class="bash">
    	# webpack.config.js 생성
	$ touch webpack.config.js
                        </code></pre>

                        <pre><em class="file_name"><i class="devicons devicons-javascript"></i>&nbsp;webpack.config.js</em><code class="javascript">


    // node에서 제공되는 path 사용하여 OS에 따른 파일경로 이슈를 방지
    const path = require('path');
	module.exports = {
        // entry는 진입 파일의 경로 + 파일명
	    entry: './src/app.js',

        // output은 webpack의 번들링 결과물에 대한 설정
        // path - 디렉터리경로
        // publicPath - 브라우저에서 접근하는 경로
        // fileName - 번들링된 파일명
	    output: {
	        filename: './dist/app.bundle.js'
	    }
	}
                        </code></pre>
                    </section>


                    <section>
                        <pre><em class="file_name"><i class="devicons devicons-npm"></i>&nbsp;package.json</em><code class="javascript">
    "scripts": {
        "dev": "webpack -d --watch",
        "prod": "webpack -p"
    }
                        </code></pre>

                        <pre><code class="bash">
    $ npm run dev      # 디벨로프 모드
    or
    $ npm run prod    # 프로덕션 모드
                        </code></pre>
                    </section>


                    <section>
                        <h2>HTML webpack Plugin</h2>
                        <p><a href="https://github.com/jantimon/html-webpack-plugin" target="_blank">html-webpack-plugin</a> 이용해서 index.html 자동으로 만들기</p>
                        <p>js를 배포하다보면 캐쉬 문제로 v= 을 붙여 주어야 할 때가 많다.
html-webpack-plugin을 이용하면 html에 들어갈 내용을 내가 외부에서 동적으로 바꿔서 생성을 할 수 있다.
minify 옵션으로 min 파일을 만들 수 있고, <a href="https://github.com/mde/ejs" target="_blank">ejs템플릿</a>을 사용할 수도 있습니다.</p>


                        <pre><code class="bash">
	$ npm i html-webpack-plugin --save-dev
                        </code></pre>
                    </section>


                    <section>
                        <pre><em class="file_name"><i class="devicons devicons-javascript"></i>&nbsp;webpack.config.js</em><code class="javascript">
	const HtmlwebpackPlugin = require('html-webpack-plugin');
	const path = require('path');

	module.exports = {
	    // ...
	    plugins: [
	        new HtmlwebpackPlugin({
	            title: 'Project Demo',
	            minify: {
	                collapseWhitespace: true
	            },
	            hash: true,
	            template: './src/index.html'
	        })
	    ]
	}
                        </code></pre>
                    </section>


                    <section>
                        <pre><em class="file_name"><i class="devicons devicons-html5"></i>&nbsp;index.html</em><code class="html">
    &lt;html&gt;
        &lt;head&gt;
            &lt;meta charset="utf-8"&gt;
            &lt;title&gt;<%= htmlwebpackPlugin.options.title %>&lt;/title&gt;
        &lt;/head&gt;
        &lt;body&gt;
            &lt;div id="root"&gt;&lt;/div&gt;
        &lt;/body&gt;
    &lt;/html&gt;
                        </code></pre>
                    </section>


                    <section>
                        <h2>Style, CSS loaders</h2>
                        <ul>
                        	<li>css-loader: css 파일들을 읽어주고</li>
                        	<li>style-loader: 읽은 css 파일들을 style 태그로 만들어 head 태그 안에 생성</li>
                        </ul>

                        <pre><code class="bash">
	$ npm i css-loader style-loader --save-dev
                        </code></pre>

                       	<pre><em class="file_name"><i class="devicons devicons-javascript"></i>&nbsp;webpack.config.js</em><code class="javascript">
	module.exports = {
	    // ...
		module: {
		    rules: [{
		        test: /\.css$/,
		        use: [ 'style-loader', 'css-loader' ]
		    }]
		}
	}
                        </code></pre>
                    </section>



                    <section>
                        <pre><em class="file_name"><i class="devicons devicons-javascript"></i>&nbsp;app.js</em><code class="javascript">
    const css = require('./app.css');
                        </code></pre>
                    </section>



                    <section>
                        <h2>Sass loaders</h2>

                        <pre><code class="bash">
    $ npm i sass-loader node-sass --save-dev
                        </code></pre>

                        <pre><em class="file_name"><i class="devicons devicons-javascript"></i>&nbsp;webpack.config.js</em><code class="javascript">
    module.exports = {
        // ...
        module: {
            rules: [{
                test: /\.scss$/,
                use: [ 'style-loader', 'css-loader', 'sass-loader' ]
            }]
        }
    }
                        </code></pre>
                    </section>


                    <section>
                        <pre><em class="file_name"><i class="devicons devicons-javascript"></i>&nbsp;app.js</em><code class="javascript">
    const css = require('./app.scss');
                        </code></pre>
                    </section>


                    <section>
                        <h2>SCSS 컴파일, CSS 파일 생성</h2>
                        <p>Extract Text Plugin</p>

                        <pre><code class="bash">
    $ npm i extract-text-webpack-plugin --save-dev
                        </code></pre>

                    </section>

                    <section>
                        <pre><em class="file_name"><i class="devicons devicons-javascript"></i>&nbsp;webpack.config.js</em><code class="javascript">
    const ExtractTextPlugin = require("extract-text-webpack-plugin");
    module.exports = {
        module: {
            rules: [
                {
                    test: /\.scss$/,
                    use: ExtractTextPlugin.extract({
                        fallback: 'style-loader',
                        use: ['css-loader','sass-loader'],
                        publicPath: '/dist'
                    })
                }
            ]
        },
        plugins: [
            new ExtractTextPlugin({
                filename: 'app.css'
            })
        ]
    }
                        </code></pre>
                    </section>



                    <section>
                        <h2>File Loader</h2>
                        <p>
                        웹팩은 모든 것을 모듈로 처리한다고 했는데 CSS 파일도 모듈로 다룬다.
                    CSS에서 url() 함수에 파일명을 지정할수 있는데 이를 모듈에서 발견하면 웹팩은 file-loader를 통해 파일을 복사(실제 사용되는 파일만 복사)</p>

                        <pre><code class="bash">
    $ npm i file-loader --save-dev

    # 이미지 최적화
    $ npm i image-webpack-loader --save-dev
                        </code></pre>
                    </section>



                    <section>
                        <pre><em class="file_name"><i class="devicons devicons-javascript"></i>&nbsp;webpack.config.js</em><code class="javascript">
    module.exports = {
        // ...
        module: {
            rules: [
                {
                    test: /\.(jpe?g|png|gif|svg)$/i,
                    use: [
                            'file-loader?name=images/[name].[ext]',
                            'image-webpack-loader'
                    ]
                }
            ]
        }
    }
                        </code></pre>
                    </section>



                    <section>
                        <h2>URL Loader</h2>
                        <p>작은 이미지나 글꼴 파일은 복사하지 않고 문자열 형태로 변환 (<a href="https://en.wikipedia.org/wiki/Data_URI_scheme" target="_blank">Data URI Scheme</a>)</p>


                        <pre><code class="bash">
    $ npm i url-loader --save-dev
                        </code></pre>
                    </section>


                    <section>
                        <p>10Kb 미만인 svg 파일을 url-loader로 처리하도록 변경</p>
                        <pre><em class="file_name"><i class="devicons devicons-javascript"></i>&nbsp;webpack.config.js</em><code class="javascript">
    module.exports = {
        // ...
        module: {
            rules: [
                {
                    test: /\.(woff2?|svg)$/
                    use: [
                            'url-loader?limit=10000&name=fonts/[name].[ext]' // 10kb
                    ]
                }
            ]
        }
    }
                        </code></pre>
                    </section>





                    <section>
                        <h2>webpack dev server</h2>
                        <p></p>

                        <pre><code class="bash">
    $ npm i webpack-dev-server --save-dev
                        </code></pre>
                    </section>


                    <section>
                        <pre><em class="file_name"><i class="devicons devicons-javascript"></i>&nbsp;webpack.config.js</em><code class="javascript">
    module.exports = {
        devServer: {
            contentBase: path.join(__dirname, 'dist'),
            compress: true,
            port: 8080,
            stats: 'errors-only',
            open: true
        }
    }
                        </code></pre>

                        <pre><em class="file_name"><i class="devicons devicons-npm"></i>&nbsp;package.json</em><code class="javascript">
    "scripts": {
        "dev": "webpack-dev-server",
        "prod": "webpack -p"
    }
                        </code></pre>
                    </section>



                    <section>
                        <h2>HMR (Hot Module Replacement)</h2>
                        <p>HMR은 내용이 변경된 모듈을 페이지 새로고침 없이 런타임에서 업데이트합니다. 업데이트에 실패할 경우 새로고침을 수행합니다.</p>
                        <p>우리가 코드를 수정하거나 추가하고 저장할 때마다 webpack 이 이를 감지하고 컴포넌트의 상태를 잃지않고 페이지를 새로고침할 필요도 없이 코드를 수정하여준다.</p>

                        <pre><code class="bash">
    # 페이지를 로딩하지 않는다.
    $ webpack-dev-server

    # 전체 페이지를 로딩 한다.(Live Reload)
    $ webpack-dev-server --inline

    # 부분 로딩  또는 전체 페이지 로딩
    $ webpack-dev-server --hot --inline
                        </code></pre>
                    </section>

                    <section>
                        <pre><em class="file_name"><i class="devicons devicons-javascript"></i>&nbsp;webpack.config.js</em><code class="javascript">
    const webpack = require('webpack');

    module.exports = {
        devServer: {
            hot: true,
            inline: true
        },
        plugins: [
            new webpack.HotModuleReplacementPlugin()
        ]
    }
                        </code></pre>
                    </section>




                    <section>
                        <h2>ES2015 to ES5 with Babel</h2>
                        <p>IE환경을 지원하면서도 ES2015를 쓰기 위해서는 babel 같은 트랜스파일러(Transpiler)가 필수다.
                            webpack에서는 이를 위해 babel-loader에 통과시켜서 ES5 이하의 JavaScript로 만든다.
                        babel-loader를 사용하기 위해서 먼저 babel-loader를 설치한다.</p>

                        <p>이제부터 프로젝트에 포함된 모든 .js 확장자 파일은 babel-loader를 거치면서 ES5로 트랜스파일된다. 코드를 ES2015로 변경하여 테스트 해보자.</p>

                        <pre><code class="bash">
    $ npm i --save-dev babel-loader babel-core babel-preset-env
                        </code></pre>


                        <pre><em class="file_name"><i class="devicons devicons-npm"></i>&nbsp;.babelrc</em><code class="javascript">
    {
        "presets": [
            ["es2015", { "modules": false }]
        ]
    }
                        </code></pre>
                    </section>



                    <section>
                        <pre><em class="file_name"><i class="devicons devicons-javascript"></i>&nbsp;webpack.config.js</em><code class="javascript">
    module: {
        rules: [
            {
                test: /\.js$/,
                exclude: /node_modules/,
                use: {
                    loader: 'babel-loader',
                    options: {
                        presets: ['env']
                    }
                }
            }
        ]
    }
                        </code></pre>
                    </section>




                    <section>
                        <h2>Transpiled from ES2015 to ES5 with Babel</h2>
                        <p></p>
                        <pre><code class="nohighlight">
    npm install babel-core babel-loader babel-preset-es2015 --save-dev
                        </code></pre>

                        <pre><em class="file_name"><i class="devicons devicons-javascript"></i>&nbsp;webpack.config.js</em><code class="javascript">
    module.exports = {
        // ...
        module: {
            rules: [
                test: /\.js$/,
                exclude: [/node_modules/],
                use: [{
                    loader: 'babel-loader',
                    options: {presets: ['es2015']}
                }]
            ]
        }
    };
                        </code></pre>



                    </section>



                    <section>
                        <h2>스타일, CSS and Sass 로더</h2>
                        <p></p>
                        <pre><code class="nohighlight">
    npm install css-loader style-loader --save-dev
    npm install sass-loader node-sass --save-dev
                        </code></pre>


                        <pre><em class="file_name"><i class="devicons devicons-javascript"></i>&nbsp;webpack.config.js</em><code class="javascript">
    module.exports = {
        // ...
        module: {
            rules: [
                {
                    test: /\.scss$/,
                    use : ['style-loader', 'css-loader', 'sass-loader']
                }
            ]
        }
    };
                        </code></pre>


                        <aside class="notes">
참고 : 로더는 RTL (오른쪽에서 왼쪽)으로 처리됩니다.

CSS를로드하기 위해 webpack을 사용하려면 css-loader 와 style-loader라는 두 개의 로더가 필요합니다 .
css-loader는 CSS 파일의 내용을로드하고
style-loader는 CSS를 페이지에 삽입합니다.



로더를 설치 한 후 webpack에 다음과 같이 css 파일을 처리하도록 지시 할 수 있습니다.
                        </aside>
                    </section>


                    <section>
                        <h2>스타일, scss 변환 순수 css 변환</h2>
                        <p></p>
                        <pre><code class="nohighlight">
    npm install extract-text-webpack-plugin@2.0.0 --save-dev
                        </code></pre>


                        <pre><em class="file_name"><i class="devicons devicons-javascript"></i>&nbsp;webpack.config.js</em><code class="javascript">
    var ExtractTextPlugin = require("extract-text-webpack-plugin");
    module.exports = {
        // ...
        module: {
            rules: [
                {
                    test: /\.scss$/,
                    use: ExtractTextPlugin.extract({
                        fallback: 'style-loader',
                        use: ['css-loader','sass-loader'],
                        publicPath: '/dist'
                    })
                }
            ]
        },
        plugins: [
            new ExtractTextPlugin({
                filename: 'app.bundle.css',
                disable: false,
                allChunks: true
            })
        ]
    };
                        </code></pre>



                    </section>

                    <section>
                        <h2></h2>

                        <pre><em class="file_name"><i class="devicons devicons-javascript"></i>&nbsp;app.js</em><code class="javascript">
    const css = require('./app.scss');

    console.log('Hello from Webpack');
                        </code></pre>

                        <pre><em class="file_name"><i class="devicons devicons-html5"></i>&nbsp;index.html</em><code class="html">
    &lt;html&gt;
        &lt;head&gt;
            &lt;meta charset="utf-8"&gt;
            &lt;link rel="stylesheet" href="dist/app.bundle.css"&gt;
        &lt;/head&gt;
        &lt;body&gt;
            &lt;h1&gt;Hello Webpack&lt;/h1&gt;
            &lt;script type="text/javascript" src="dist/app.bundle.js"&gt;&lt;/script&gt;
        &lt;/body&gt;
    &lt;/html&gt;
                        </code></pre>



                    </section>

                    <section>
                        <h2>개발 서버</h2>
                        <pre><code class="nohighlight">
    npm install webpack-dev-server -D
    webpack-dev-server
                        </code></pre>

                        <pre><em class="file_name"><i class="devicons devicons-npm"></i>&nbsp;package.json</em><code class="javascript">
  "scripts": {
    //"dev": "webpack -d --watch",
    "dev": "webpack-dev-server",
    "prod": "webpack -p"
  }
                        </code></pre>

                        <pre><code class="nohighlight">
    npm run dev
                        </code></pre>

                        <aside class="notes">
                        유사 browsersync의 라이브 리로드, 웹팩은 생성 dev에 서버 쉽게 우리의 코드를 확인 할 수 있습니다. 서버는 프로젝트의 모든 변경 사항을 수신 한 다음 해당 변경 사항을 브라우저에 주입합니다.
                        </aside>
                    </section>


                    <section>
                        <h2>Webpack Dev Server Configuration</h2>

                        <pre><em class="file_name"><i class="devicons devicons-javascript"></i>&nbsp;webpack.config.js</em><code class="javascript">
    var ExtractTextPlugin = require("extract-text-webpack-plugin");
    module.exports = {
        // ...
        devServer: {
            contentBase: path.join(__dirname, "dist"),
            compress: true,
            port: 9000,
            stats: "errors-only",
            open: true
        }
    };
                        </code></pre>


                        <aside class="notes">
                        문법이 잘못되어 저장하면 에러를 cmd 창에 보여준다.
                        </aside>
                    </section>



                    <section>
                        <h2>Webpack 출력 최적화</h2>
                        <pre><code class="nohighlight">
    webpack -p
                        </code></pre>

                        <aside class="notes">
                        우리의 최종 webpack 번들은 생산에 적합하지 않으며, 많은 주석과 공백이 있습니다. 우리는 모두 축소가 제작용 스크립트와 스타일을 준비하는 데 좋다는 것을 알고 있습니다.
                        프로덕션 환경에서 번들을 준비하려면 프로젝트의 루트에서 다음을 실행할 수 있습니다.
                        </aside>
                    </section>





                    <section>
                        <h2>entry</h2>
                        <p>entry 부분이 웹팩이 파일을 읽어들이기 시작하는 부분입니다. app이 객체의 키로 설정되어 있는데 이 부분 이름은 자유롭게 바꾸시면 됩니다. 저 키가 app이면 결과물이 app.js로 나오고, zero면 zero.js로 나옵니다.</p>


새롭게 보이는 속성을 각각 살펴봅시다:

entry - 번들의 엔트리 포인트로써 번들하기 색션에서 이미 논의했습니다. Webpack은 여러 번들을 생성하는 진입점을 허용하기 때문에 배열입니다.

output - Webpack의 최종 결과물이 되는 형태를 명시합니다.

path - Webpack의 최종 결과물이 되는 형태를 명시합니다.
filename - 번들 파일의 이름을 지정합니다.
이제 webpack 명령을 실행하면, dit라는 폴더에 bundle.js 파일을 생성합니다.


                        <pre><code class="javascript">
    {
      entry: {
        app: '',
        zero: '',
      }
    }
                        </code></pre>
                        <pre><code class="javascript">
    {
      entry: {
        app: ['a.js', 'b.js'],
      },
    }
                        </code></pre>

                        <p></p>


                        <aside class="notes">
                            위의 경우는 a.js랑 b.js가 한 파일로 엮여 app.js라는 결과물로 나옵니다. 이렇게 웹팩은 entry의 js 파일부터 시작해서 import, require 관계로 묶여진 다른 js까지 알아서 파악한 뒤 모두 entry에 기재된 키 개수만큼으로 묶어줍니다.
                        </aside>
                    </section>


                    <section>
                        <h2>output</h2>
                        <p>이제 결과물이 어떻게 나올지 설정을 해야 합니다.</p>

                        <pre><code class="javascript">
    {
      output: {
        path: '/dist',
        filename: '[name].js',
        publicPath: '/',
      },
    }
                        </code></pre>

                        <aside class="notes">
                            path랑 publicPath가 헷갈릴 수 있겠네요. path는 output으로 나올 파일이 저장될 경로입니다. publicPath는 파일들이 위치할 서버 상의 경로입니다. Express에 비유하면 express.static 경로와 비슷한 겁니다. filename을 보시면 좀 이상하게 생긴 게 있습니다. [name].js라고 되어 있는데요. 이렇게 써줘야 [name]에 아까 app이나 zero가 들어가 app.js, zero.js로 결과물이 나옵니다.

다른 옵션으로는 [hash]나 [chunkhash]가 있습니다. [hash]는 매번 웹팩 컴파일 시 랜덤한 문자열을 붙여줍니다. 따라서 캐시 삭제 시 유용합니다. [hash]가 컴파일할 때마다 랜덤 문자열을 붙여준다면 [chunkhash]는 파일이 달라질 때에만 랜덤 값이 바뀝니다. 이것을 사용하면 변경되지 않은 파일들은 계속 캐싱하고 변경된 파일만 새로 불러올 수 있습니다.
                        </aside>
                    </section>



                    <section>
                        <h2>loader</h2>
                        <p>이제부터 막강한 웹팩의 기능들이 나옵니다. 바로 로더(loader)입니다. 보통 웹팩을 사용하면 babel을 주로 같이 사용합니다. ES2015 이상의 문법들은 IE같은 구형 브라우저랑 호환시키기 위함인데요. 또는 jsx같은 react 문법을 컴파일하려고 하는 목적도 있습니다. babel을 웹팩2와 연결시켜 볼까요? 일단 설치부터 해봅니다.</p>

                        <pre><code class="javascript">
    npm i -D babel-loader babel-core babel-preset-es2015 babel-preset-react babel-preset-stage-0
                        </code></pre>

                        <p>일단 babel-loader와 babel-core는 필수이고요. 나머지 preset들은 선택입니다. react는 react 하시는 분만 설치하면 되고요. stage-0은 es2015보다도 더 최신 기술을 위한 겁니다.</p>

                        <pre><code class="javascript">
    {
      module: {
        rules: [{
          test: /\.jsx?$/,
          loader: 'babel-loader',
          options: {
            presets: ['es2015', 'react', 'stage-0'],
          },
          exclude: ['/node_modules'],
        }],
      },
    }
                        </code></pre>

                        <aside class="notes">
혹시 다른 사이트에서 rules나 use 대신 loaders를 쓰고, options 대신 query를 쓰는 곳이 있다면, 웹팩1에 대한 강좌입니다. 웹팩2에서 바뀌었습니다. (물론 하위호환을 위해 여전히 지원하긴 합니다)

위와 같이하면 test 정규식조건(js나 jsx 파일)에 부합하는 파일들을 loader에 지정한 로더가 컴파일해줍니다. options는 로더에 대한 옵션으로 아까 설치한 presets들을 적용하고 있는 게 보입니다. exclude는 제외할 폴더나 파일로, 바벨로 컴파일하지 않을 것들을 지정해줍니다. 바벨로는 컴파일하지 않지만 웹팩으로는 컴파일합니다. 반대로 include로 꼭 이 로더를 사용해서 컴파일할 것들을 지정해줄 수도 있습니다.
                        </aside>
                    </section>


                    <section>
                        <h2>plugin</h2>
                        <p>플러그인은 약간 부가적인 기능입니다. 다양한 플러그인들이 나와있는데 이를 사용하면 효과적으로 번들링을 할 수 있습니다. 예를 들면 압축을 한다거나, 핫리로딩을 한다거나, 파일을 복사하는 등의 부수적인 작업을 할 수 있습니다. 다양한 플러그인들이 패키지로 존재하기 때문에 쇼핑하듯 골라보세요!</p>

                        <pre><code class="javascript">
    {
      plugins: [
        new webpack.LoaderOptionsPlugin({
          minimize: true,
        }),
        new webpack.optimize.UglifyJsPlugin({
          sourceMap: true,
          compress: {
            warnings: true,
          },
        }),
        new webpack.DefinePlugin({
          'process.env.NODE_ENV': 'production',
        }),
      ],
    }
                        </code></pre>

                        <aside class="notes">
                        대표적인 웹팩 기본 제공 플러그인들입니다. LoaderOptionsPlugin은 로더들에게 옵션을 넣어주는 플러그인이고요. UglifyJsPlugin이 압축, console 제거, 소스맵 보존 등을 하는 플러그인이고, DefinePlugin은 JS 변수를 치환해주는 플러그인입니다. 이외에도 BannersPlugin, IgnorePlugin, EnvironmentPlugin, ContextReplacementPlugin 등 기본 제공 플러그인도 어마어마합니다.

웹팩2에서 플러그인들의 변경점이 있습니다. DedupePlugin은 사라졌고, OccurrenceOrderPlugin은 기본으로 켜져 있으니 더 이상 추가하지 마세요.

용량 관계로 다음 강좌에서 계속 이어집니다! 이번 시간에 주로 js를 번들링하는 방법을 살펴봤다면, 다음 시간에는 css랑 기타 파일들 번들링 방법을 알아보겠습니다.
                        </aside>
                    </section>


                    <section>
                        <h2>output</h2>
                        <p>이제 결과물이 어떻게 나올지 설정을 해야 합니다.</p>

                        <pre><code class="javascript">

                        </code></pre>


                    </section>






                </section>











                <section>
                    <h1>감사합니다.</h1>
                </section>
            </div>
        </div>

        <script src="lib/js/head.min.js"></script>
        <script src="js/reveal.js"></script>
        <script>
            // Full list of configuration options available at:
            // https://github.com/hakimel/reveal.js#configuration
            Reveal.initialize({
                controls: true,
                progress: true,
                history: true,
                center: true,

                transition: 'convex', // none/fade/slide/convex/concave/zoom

                // Optional reveal.js plugins
                dependencies: [
                    { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
                    { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                    { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                    { src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
                    { src: 'plugin/zoom-js/zoom.js', async: true },
                    { src: 'plugin/notes/notes.js', async: true }
                ]
            });

            Reveal.addEventListener( 'slidechanged', function(event) {
                // event.previousSlide, event.currentSlide, event.indexh, event.indexv
                var notes = event.currentSlide.querySelector(".notes");
                if(notes) {
                    console.info(notes.innerHTML.replace(/\n\s+/g,'\n'));
                }
            });
        </script>
    </body>
</html>