<!doctype html>
<html lang="en">

    <head>
        <meta charset="utf-8">
        <title>Webpack 2 - The Module Bundler</title>
        <meta name="description" content="A framework for easily creating beautiful presentations using HTML">
        <meta name="author" content="Hakim El Hattab">
        <meta name="apple-mobile-web-app-capable" content="yes" />
        <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
        <link rel="stylesheet" href="css/reveal.css">
        <link rel="stylesheet" href="css/theme/league.css" id="theme">
        <!-- <link rel="stylesheet" href="css/theme/ember.css" id="theme"> -->
        <!-- Code syntax highlighting -->
        <!-- <link rel="stylesheet" href="lib/css/monokai_sublime.css"> -->
        <!-- <link rel="stylesheet" href="https://highlightjs.org/static/demo/styles/atom-one-dark.css"> -->
        <!-- <link rel="stylesheet" href="https://highlightjs.org/static/demo/styles/monokai-sublime.css"> -->
        <!--<link rel="stylesheet" href="https://highlightjs.org/static/demo/styles/monokai.css">       -->
        <link rel="stylesheet" href="https://highlightjs.org/static/demo/styles/atom-one-dark.css">       
        <link rel="stylesheet" href="https://code.cdn.mozilla.net/fonts/fira.css">
        <link rel='stylesheet' href='lib/font/devicons/devicons.css'>
        <style type="text/css">
        .reveal{font-size:24px}
        .txl{text-align:left;display:inline-block}
        .devicons-javascript{color:#f5de19}
        .devicons-html5{color:#e44f26}
        .devicons-css3{color:#1572b6}
        .devicons-npm{color:#a23332}
        .devicons-sass{color:#cd6799}
        </style>
        <!-- Printing and PDF exports -->
        <script>
            var link = document.createElement( 'link' );
            link.rel = 'stylesheet';
            link.type = 'text/css';
            link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
            document.getElementsByTagName( 'head' )[0].appendChild( link );
        </script>
        <!--[if lt IE 9]>
        <script src="lib/js/html5shiv.js"></script>
        <![endif]-->
    </head>

    <body>
        <div class="reveal">
            <!-- Any section element inside of this container is displayed as a slide -->
            <div class="slides">
                <section>
                    <img src="img/logo-on-dark-bg.png " alt="" style="width:50%">
                    <!-- <p style="margin-top:-14px;font-size:30px">javascript module bundler</p> -->
                    <p>2017. 0. 00.</p>
                    <p>IT 개발2팀 UI파트 - 김재호</p>
                </section>

                <section>
                    <h2>The Agenda</h2>
                    <ul>
                        <li>Javascript 모듈의 필요성</li>
                        <li>Webpack 소개</li>
                    </ul>
                </section>

                <section>
                    <section>
                        <h2>Javascript 모듈의 필요성</h2>
                    </section>

                    <section>
                        <h3>모듈 정의</h3>
                        <ul>
                            <li>코드를 여러개의 파일로 분리.</li>
                            <li>자주 사용되는 코드를 필요할 때마다 재사용.</li>
                            <li>독립된 스코프를 가지므로 전역변수 사용을 줄이고, 그로 인한 문제점을 예방.</li>
                            <li>어느 한 부분을 수정해도 전체 서비스에 영향을 주지 않도록 서비스 모듈간의 결합도를<br> 최소화하여 관리 용이함.</li>
                        </ul>

                        <aside class="notes">
                        좋은 프로그램 코드의 조건 낮은 결합도와 높은 응집도
                        </aside>
                    </section>

                    <section>
                        <h2>일반적인 방식</h2>
                        <pre><em class="file_name"><i class="devicons devicons-html5"></i>&nbsp;index.html</em><code class="html">
    &lt;!DOCTYPE&nbsp;html&gt;
    &lt;body&gt;
    &lt;script src="../js/lib/jquery.min.js"&gt;&lt;/script&gt;
    &lt;script src="../js/lib/bootstrap.min.js"&gt;&lt;/script&gt;
    &lt;script src="../js/app.js"&gt;&lt;/script&gt;
    &lt;script&gt; 
        $(function() { 
            //... 
        }); 
    &lt;/script&gt;
    &lt;/body&gt;
                        </code></pre>
                        <ul>
                            <li>일반적으로 코드가 전역에서 실행되어 글로벌 스코프가 쉽게 오염됩니다.</li>
                            <li>파일을 로드하기 위해 올바른 의존성 순서를 알고있어야 합니다.</li>
                            <li>만약 동일한 이름을 가진 객체가 전역에 노출이 되면 이름을 바꾸지 않는 한 함께 사용할 수 없습니다.</li>
                            <li>웹페이지가 커질수록 script 태그 수가 늘어납니다.</li>
                        </ul>

                        <aside class="notes">
자바스크립트를 어느정도 다뤄본 사람이라면 자바스크립트의 스코프 관리는 지저분하다는 것을 알 수 있다.
script 태그를 이용하여 다음과 같이 불러오고 다른 코드에서 이 파일이 전역에 노출하는 객체를 사용한다.
스크립트를 라이브러리에 포함시키고 global 객체를 사용했다.
따라서 이런 코드를 감싸는(wrapping) 코드가 필요하다. 만약 이것이 없다면 전역 스코프(브라우저에서는 window)가 더렵혀진다.
Bootstrap 같은경우 Jquery에 높은 의존성을 가지고 있기 떄문에 Jquery 파일을 먼저 불러오고 나서 Bootstrap의 .js 파일들을 불러와야한다.
                        </aside>
                    </section>

                    <section>
                        <h2>전역(Global Scope)를 오염 시키지 않기 위해서</h2>
                        <pre><code class="javascript">
    //IIFE (Immediately Invoked Founction Expression)
    (function() { 
        ... 
    })();
                        </code></pre>

                        <pre><code class="javascript">
    //'App' 같은 하나의 전역객체 밑에 네임스페이스를 갖습니다.
    var App = {}; 
    App.Models = {}; 
    App.Models.Note = function() {};
                        </code></pre>

                    </section>


                    <section>
                        <h2>앞으로의 방식 (ES6 modules)</h2>
                        <pre><code class="javascript">
    //라이브러리는 공통 모듈 포맷으로 객체에 export 후,
    export default function $() { ... }
                        </code></pre>

                        <pre><code class="javascript">
    //모듈을 local scope에 import해서 사용 할 수있습니다.
    import $ from 'js/lib/jquery'; 
    
    $(function() { ... });
                        </code></pre>
                        <ul>
                            <li>더 이상 global이 필요하지 않습니다.</li>
                            <li>source 순서에 독립적 입니다.</li>
                            <li>코드상의 namespace가 필요없습니다.</li>
                            <li>필요할 때 모듈을 로드 할 수 있습니다.</li>
                        </ul>
                    </section>

                    <section>
                        <h2>현재 자바스크립트 모듈은..</h2>
                        <p>일단 사용되고 있는 많은 모듈 포맷이 있습니다.</p>
                        <ul>
                            <li>CommonJS</li>
                            <li>AMD (Asynchronous Module Definition)</li>
                            <li>UMD (Universal Module Definition)</li>
                            <li>ES6 Modules</li>
                        </ul>
                        <aside class="notes">
                        자바스크립트의 중요성이 높아지면서 이러한 모듈화를 위한 표준들이 만들어지고 여러 환경에서 지원되기 시작했습니다. 언어 자체가 지니는 한계로 자바스크립트는 모듈 시스템을 지원하지 않지만, 이러한 한계를 극복하기 위해 여러 툴이 사용되고 있습니다.
                        </aside>
                    </section>

                    <section>
                        <p>IFFE, AMD, CommonJS 스타일의 자바스크립트 모듈 시스템을 사용하여 파일을 분할하고,<br>HTTP 요청을 줄여 네트웍 성능 개선을 위해 자바스크립트 파일을 하나로 합치기도 합니다.</p>
                        <p>웹팩은 이러한 작업을 하는데 적합한 도구 입니다.</p>
                        <aside class="notes">
                        자바스크립트의 중요성이 높아지면서 이러한 모듈화를 위한 표준들이 만들어지고 여러 환경에서 지원되기 시작했습니다. 언어 자체가 지니는 한계로 자바스크립트는 모듈 시스템을 지원하지 않지만, 이러한 한계를 극복하기 위해 여러 툴이 사용되고 있습니다.
                        </aside>
                    </section>


                    <section>
                            http://2ality.com/2013/11/es6-modules-browsers.html

                            모듈. 자바 스크립트의 일반적인 run-to-completion 의미와 일치하려면 모듈의 본문을 중단없이 실행해야합니다. 모듈 가져 오기에는 두 가지 옵션이 있습니다.
본문이 실행되는 동안 동 기적으로 모듈을로드하십시오. 이것이 바로 Node.js의 기능입니다.
본문이 실행되기 전에 모든 모듈을 비동기 적으로로드하십시오. 이것이 AMD 모듈의 처리 방법입니다. 그것은 모듈이 인터넷을 통해로드되기 때문에 브라우저를위한 유일한 옵션입니다. 그렇지 않으면 실행이 너무 오랫동안 일시 중지됩니다. 추가 이점으로,이 접근법은 하나의 모듈이 여러 모듈을 병렬로로드 할 수 있도록합니다.
스크립트. 스크립트는 일반적으로로드되거나 동 기적으로 실행됩니다. JavaScript 스레드는 코드가로드되거나 실행될 때까지 중단됩니다.


ECMAScript 6는 Node.js의 동기식 구문과 AMD의 비동기 적재 방식을 모두 제공합니다. ECMAScript 6 모듈은 모두 Node.js 모듈보다 구문 적으로 유연성이 떨어집니다. 가져 오기 및 내보내기는 최상위 레벨에서 이루어져야합니다. 즉 조건부 일 수도 없습니다. 이 제한은 ECMAScript 6 모듈 로더가 모듈에서 가져온 모듈을 정적으로 분석하고 모듈을로드하기 전에로드합니다.
스크립트의 동시성을 고려할 때 단순히 가져 오기 및 내보내기 기능을 추가하고이를 모듈로 변환 할 수 없다는 것은 명백합니다. 모듈 코드를 다르게 처리하는 방법이 있어야합니다. 따라서 script태그 를 대체하고 완전히 비동기 인 모듈에 대한 새로운 태그 moduleTag 이 있습니다 . 
                        <h2>JavaScript 모듈화</h2>
                        <ul>
                            <li>동적 로딩 - UI 초기 구현에 필요한 파일만 먼저 불러오고, 나머지는 필요에 따라 개별 호출</li>
                            <li>의존성 관리 - JS 파일간 종속되는 모듈들의 리스트를 명시적으로 기술함</li>
                            <li>모듈 - 전역 공간을 오염시키지 않아 JS 파일 간 충돌로 인한 오류를 사전에 방지</li>
                        </ul>
                    </section>

                    <section>
                        <h2></h2>
                        <aside class="notes">
                        </aside>
                    </section>
                </section>




                <section>
                    <section>
                        <h2>Webpack 소개</h2>
                    </section>

                    <section>
                        <h2>번들러 끝판왕 Webpack!!</h2>
                        <p><img src="img/cover-1.jpg" alt="" style="width:70%"></p>

                        <aside class="notes">
                        https://blog.qmo.io/javascript-tooling-the-evolution-and-future-of-js-front-end-build-tools/
                        </aside>
                    </section>


                    <section>
                        <h2></h2>
                        <img src="https://cdn.filepicker.io/api/file/QIuZVivBTFWIu8LN9i3E" alt="">
                        <p>번들러 끝판왕 웹팩
                         그림처럼 여러 파일들을 하나로 합쳐줍니다.
                            JS가 점점 중요해지면서 JS 자체만으로도 엄청난 <strong>의존 관계</strong>가 생겼습니다.</p>
                        <p>ES6 모듈, RequireJS, CommonJS같은 JS 모듈 시스템들이 나오면서 JS 파일도 다른 프로그래밍 언어처럼 모듈 개념이 생겼습니다. import나 require로 js끼리 서로 의존합니다. 특히 노드로 만들다 보면 모듈이 기본 수 백개에서 많게는 수 만개까지 갑니다. 이런 것을 하나의 JS로 합쳐주는 거죠.</p>

                        <aside class="notes">
                        </aside>
                    </section>

                </section>




                <section>
                    <section>
                        <h2>뭘 하고 싶니?</h2>

                        <p>webpack을 통해 무엇을 자동으로 하고 싶은지 적어봅시다.</p>
                        <ul>
                            <li>클라이언트 사이드에서 ES6 사용하기</li>
                            <li>클라이언트 사이드 코드 변경 시 브라우저 자동으로 새로고침하기</li>
                            <li></li>
                            <li></li>
                        </ul>

                        <h3>이에 필요한 플러그인들은?</h3>
                        <ul>
                            <li>babel-loader (webpack 에서 babel 을 사용하기 위한 플러그인)</li>
                            <li></li>
                            <li>gulp-webpack</li>
                            <li>browser-sync</li>
                        </ul>

                        <p>자 이제 설치 해 볼까요?</p>

                        <aside class="notes">
                        </aside>
                    </section>
                </section>


                <section>
                    <section>
                        <h2>클라이언트 사이드에서 ES6 및 import 기능 사용하기</h2>

                        <p>클라이언트 사이드에서 단순히 ES6 문법을 사용하려면 babel 을 사용하면 됩니다. 단, 이걸 한다고 해서 import 기능 까지 호환 되지는 않죠.

클라이언트 사이드에서도 import 기능을 사용 하려면 필요한것은 바로 Module Bundler 입니다.
Module Bundler 는 브라우저단에서도 CommonJS 스타일을 사용 할 수 있게 해주는 도구입니다.

이는 대표적으로 Browserify와 Webpack이 있는데요,
여러 로더를 지원하고 자체적으로 최적화가 이미 되어있는 webpack 을 사용</p>

                        <h3> config 파일 작성</h3>
                        <ul>
                            <li>entry: ./src/js/main.js 파일을 가장 처음으로 읽습니다.
                            그리고 그 파일에서부터 import 된 파일들을 계속해서 읽어가면서 연결시켜줍니다.
                            </li>
                            <li>output: 읽은 파일을 모두 합쳐서 /dist/js/bundle.js 에 저장합니다.</li>
                            <li>module: 읽은 파일들을 babel-loader 를 통하여 ES6 스크립트를 컴파일해줍니다.</li>
                            <li>plugins: UglifyJsPlugin 을 사용하여 컴파일한 스크립트를 minify 합니다.</li>
                        </ul>

                        <p>webpack이 잘 되는지 확인하려면 우선.. js 코드에서도 ES6 및 import 를 사용하는 예제를 만들어봐야겠죠?</p>

                        <h3>예제 모듈</h3>
                        <pre><em class="file_name"><i class="devicons devicons-javascript"></i>&nbsp;sample.js </em><code class="javascript">
    class Sample {
        constructor(name) {
            this.name = name;
        }

        say() {
            console.log("HI, I AM ", this.name);
        }
    }

    export default Sample;
                        </code></pre>

                        <pre><em class="file_name"><i class="devicons devicons-javascript"></i>&nbsp;app.js </em><code class="javascript">
    import Sample from './sample';

    let sample = new Sample('velopert');
    sample.say();

                        </code></pre>


                        <aside class="notes">
                        </aside>
                    </section>
                </section>





                <section>
                    <section><h2>Project Start</h2></section>

                    <section>
                        <h2>설치</h2>

                        <p><a href="https://nodejs.org/ko/" target="_blank" title="Node.js"><img width="34%" alt="Node.js logo 2015" src="img/nodejs.png"/></a></p>
                        <p style="margin:0"><img style="margin:0" src="img/plus.png" width="2%" alt=""></p>
                        <p><a href="https://www.npmjs.com/" target="_blank" title="Npm"><img width="20%" alt="Node.js logo 2015" src="img/npm.png"/></a></p>

                        <pre><code class="nohighlight">
    npm init

    npm install webpack -g
    or
    npm install webpack --save-dev
                        </code></pre>

                        <aside class="notes">
                        웹팩은 노드 기반의 빌드 툴입니다. 노드 설치가 선행되었다는 가정하에 NPM으로 예제 코드를 시작하겠습니다.
                        Webpack의 모든 기능을 사용하려면 전역으로 설치
                        그러나 Webpack의 일부 기능이나 최적화 플러그인 정도만 필요한 경우라면 로컬에 설치
                        </aside>
                    </section>


                    <section>
                        <h2>디렉터리 구조</h2>
                        <pre><code class="nohighlight">
    ├── dist                  패키지 출력 디렉토리, 프로덕션 환경 배포 파일
    ├── node_modules          npm plugin 파일
    ├── src
    │   ├── app.js
    │   └── app.css
    ├── index.html
    ├── package.json          프로젝트 구성 정보
    └── webpack.config.js     웹팩 설정파일
                        </code></pre>

                        <aside class="notes"></aside>
                    </section>


                    <section>
                        <h2></h2>
                        <p>빌드된 코드를 로드할 html 코드를 작성</p>

                        <pre><em class="file_name"><i class="devicons devicons-html5"></i>&nbsp;index.html</em><code class="html">
    &lt;html&gt;
        &lt;head&gt;
            &lt;meta charset="utf-8"&gt;
        &lt;/head&gt;
        &lt;body&gt;
            &lt;h1&gt;Hello Webpack 2&lt;/h1&gt;
            &lt;script type="text/javascript" src="dist/app.bundle.js"&gt;&lt;/script&gt;
        &lt;/body&gt;
    &lt;/html&gt;
                        </code></pre>


                        <aside class="notes"></aside>
                    </section>



                    <section>
                        <h2>모듈 정의와 사용</h2>
                        <p>모듈을 작성하고 module.exports 속성에 외부에 배포할 모듈을 전달해서 모듈을 정의한다.</p>


                        <aside class="notes">

                        </aside>
                    </section>




                    <section>
                        <h2></h2>
                        <p>다음으로, 우리는 app.js 파일을 만들고 우리는 console.log새로 생성 된 파일 에 간단한 문장을 추가 할 수 있습니다 .</p>

                        <pre><em class="file_name"><i class="devicons devicons-javascript"></i>&nbsp;app.js</em><code class="javascript">
    console.log('Hello from Webpack');
                        </code></pre>

                        <pre><code class="nohighlight">
    webpack ./src/app.js ./dist/app.bundle.js
                        </code></pre>

                        <aside class="notes">
                            새로 생성 된 bundle.js 를 체크 아웃하면 webpack이 자체 코드 주위에 래퍼를 생성했음을 알 수 있습니다. 이 포함 때문에 우리는 AMD 구문 또는 requirejs 를 사용하여 javascript 파일을로드 할 수 있습니다.
                        </aside>
                    </section>


                    <section>
                        <h2>설정 파일 정의</h2>
                        <pre><em class="file_name"><i class="devicons devicons-javascript"></i>&nbsp;webpack.config.js</em><code class="javascript">
    module.exports = {
        entry: './src/app.js',
        output: {
            filename: 'app.bundle.js'
        }
    };
                        </code></pre>

                        <pre><code class="nohighlight">
    webpack
                        </code></pre>

                        <aside class="notes">
                            우리가 계속 명령 줄에서 일을 계속 실행할 수는 있지만, 우리의 빌드는 점점 더 복잡해질 것입니다. 더 많은 JS 모듈, CSS, TypeScript / ES6 및 Sass 등을 가져올 때 Webpack을보다 강력하게 실행하는 방법을 원합니다.

                            이것은 config 파일이 작동하는 곳입니다.

                            config 파일을 만들기 전에 webpack 이 위에서 실행 한 명령과 같이 진입 점 및 출력 위치의 원칙에 따라 작동 한다는 것을 이해해야 합니다.

                            우리는 그냥 실행할 수 webpack있으며 여전히 동일한 결과가 있습니다.
                        </aside>
                    </section>


                    <section>
                        <h2>변경 사항보기</h2>
                        <pre><code class="nohighlight">
    webpack --watch
    or
    webpack -w
                        </code></pre>

                        <pre><em class="file_name"><i class="devicons devicons-javascript"></i>&nbsp;webpack.config.js</em><code class="javascript">
    module.exports = {
        entry: './src/app.js',
        output: {
            filename: 'app.bundle.js'
        },
        watch: true
    };
                        </code></pre>


                        <pre><em class="file_name"><i class="devicons devicons-npm"></i>&nbsp;package.json</em><code class="javascript">
    "scripts": {
        "dev": "webpack -d --watch",
        "prod": "webpack -p"
    }
                        </code></pre>

                        <pre><code class="nohighlight">
    npm run dev
                        </code></pre>

                        <aside class="notes">
                        이 명령을 실행하자마자 webpack은 프로젝트의 변경 사항을 감시하고 변경이 발생하면 기본적으로 webpack명령을 다시 실행합니다.
                        이것은 webpack에게 변경 코드를 감시하도록 지시하는 두 번째 방법입니다.
                        </aside>
                    </section>



                    <section>
                        <h2>Transpiled from ES2015 to ES5 with Babel</h2>
                        <p></p>
                        <pre><code class="nohighlight">
    npm install babel-core babel-loader babel-preset-es2015 --save-dev
                        </code></pre>

                        <pre><em class="file_name"><i class="devicons devicons-javascript"></i>&nbsp;webpack.config.js</em><code class="javascript">
    module.exports = {
        // ...
        module: {
            rules: [
                test: /\.js$/,
                exclude: [/node_modules/],
                use: [{
                    loader: 'babel-loader',
                    options: {presets: ['es2015']}
                }]
            ]
        }
    };
                        </code></pre>


                        <aside class="notes">

                        </aside>
                    </section>



                    <section>
                        <h2>스타일, CSS and Sass 로더</h2>
                        <p></p>
                        <pre><code class="nohighlight">
    npm install css-loader style-loader --save-dev
    npm install sass-loader node-sass --save-dev
                        </code></pre>


                        <pre><em class="file_name"><i class="devicons devicons-javascript"></i>&nbsp;webpack.config.js</em><code class="javascript">
    module.exports = {
        // ...
        module: {
            rules: [
                {
                    test: /\.scss$/,
                    use : ['style-loader', 'css-loader', 'sass-loader']
                }
            ]
        }
    };
                        </code></pre>


                        <aside class="notes">
참고 : 로더는 RTL (오른쪽에서 왼쪽)으로 처리됩니다.

CSS를로드하기 위해 webpack을 사용하려면 css-loader 와 style-loader라는 두 개의 로더가 필요합니다 .
css-loader는 CSS 파일의 내용을로드하고
style-loader는 CSS를 페이지에 삽입합니다.



로더를 설치 한 후 webpack에 다음과 같이 css 파일을 처리하도록 지시 할 수 있습니다.
                        </aside>
                    </section>


                    <section>
                        <h2>스타일, scss 변환 순수 css 변환</h2>
                        <p></p>
                        <pre><code class="nohighlight">
    npm install extract-text-webpack-plugin@2.0.0 --save-dev
                        </code></pre>


                        <pre><em class="file_name"><i class="devicons devicons-javascript"></i>&nbsp;webpack.config.js</em><code class="javascript">
    var ExtractTextPlugin = require("extract-text-webpack-plugin");
    module.exports = {
        // ...
        module: {
            rules: [
                {
                    test: /\.scss$/,
                    use: ExtractTextPlugin.extract({
                        fallback: 'style-loader',
                        use: ['css-loader','sass-loader'],
                        publicPath: '/dist'
                    })
                }
            ]
        },
        plugins: [
            new ExtractTextPlugin({
                filename: 'app.bundle.css',
                disable: false,
                allChunks: true
            })
        ]
    };
                        </code></pre>


                        <aside class="notes">

                        </aside>
                    </section>

                    <section>
                        <h2></h2>

                        <pre><em class="file_name"><i class="devicons devicons-javascript"></i>&nbsp;app.js</em><code class="javascript">
    const css = require('./app.scss');

    console.log('Hello from Webpack');
                        </code></pre>

                        <pre><em class="file_name"><i class="devicons devicons-html5"></i>&nbsp;index.html</em><code class="html">
    &lt;html&gt;
        &lt;head&gt;
            &lt;meta charset="utf-8"&gt;
            &lt;link rel="stylesheet" href="dist/app.bundle.css"&gt;
        &lt;/head&gt;
        &lt;body&gt;
            &lt;h1&gt;Hello Webpack 2&lt;/h1&gt;
            &lt;script type="text/javascript" src="dist/app.bundle.js"&gt;&lt;/script&gt;
        &lt;/body&gt;
    &lt;/html&gt;
                        </code></pre>


                        <aside class="notes"></aside>
                    </section>

                    <section>
                        <h2>개발 서버</h2>
                        <pre><code class="nohighlight">
    npm install webpack-dev-server -D
    webpack-dev-server
                        </code></pre>

                        <pre><em class="file_name"><i class="devicons devicons-npm"></i>&nbsp;package.json</em><code class="javascript">
  "scripts": {
    //"dev": "webpack -d --watch",
    "dev": "webpack-dev-server",
    "prod": "webpack -p"
  }
                        </code></pre>

                        <pre><code class="nohighlight">
    npm run dev
                        </code></pre>

                        <aside class="notes">
                        유사 browsersync의 라이브 리로드, 웹팩은 생성 dev에 서버 쉽게 우리의 코드를 확인 할 수 있습니다. 서버는 프로젝트의 모든 변경 사항을 수신 한 다음 해당 변경 사항을 브라우저에 주입합니다.
                        </aside>
                    </section>


                    <section>
                        <h2>Webpack Dev Server Configuration</h2>

                        <pre><em class="file_name"><i class="devicons devicons-javascript"></i>&nbsp;webpack.config.js</em><code class="javascript">
    var ExtractTextPlugin = require("extract-text-webpack-plugin");
    module.exports = {
        // ...
        devServer: {
            contentBase: path.join(__dirname, "dist"),
            compress: true,
            port: 9000,
            stats: "errors-only",
            open: true
        }
    };
                        </code></pre>


                        <aside class="notes">
                        문법이 잘못되어 저장하면 에러를 cmd 창에 보여준다.
                        </aside>
                    </section>



                    <section>
                        <h2>Webpack 출력 최적화</h2>
                        <pre><code class="nohighlight">
    webpack -p
                        </code></pre>

                        <aside class="notes">
                        우리의 최종 webpack 번들은 생산에 적합하지 않으며, 많은 주석과 공백이 있습니다. 우리는 모두 축소가 제작용 스크립트와 스타일을 준비하는 데 좋다는 것을 알고 있습니다.
                        프로덕션 환경에서 번들을 준비하려면 프로젝트의 루트에서 다음을 실행할 수 있습니다.
                        </aside>
                    </section>





                    <section>
                        <h2>entry</h2>
                        <p>entry 부분이 웹팩이 파일을 읽어들이기 시작하는 부분입니다. app이 객체의 키로 설정되어 있는데 이 부분 이름은 자유롭게 바꾸시면 됩니다. 저 키가 app이면 결과물이 app.js로 나오고, zero면 zero.js로 나옵니다.</p>


새롭게 보이는 속성을 각각 살펴봅시다:

entry - 번들의 엔트리 포인트로써 번들하기 색션에서 이미 논의했습니다. Webpack은 여러 번들을 생성하는 진입점을 허용하기 때문에 배열입니다.

output - Webpack의 최종 결과물이 되는 형태를 명시합니다.

path - Webpack의 최종 결과물이 되는 형태를 명시합니다.
filename - 번들 파일의 이름을 지정합니다.
이제 webpack 명령을 실행하면, dit라는 폴더에 bundle.js 파일을 생성합니다.


                        <pre><code class="javascript">
    {
      entry: {
        app: '',
        zero: '',
      }
    }
                        </code></pre>
                        <pre><code class="javascript">
    {
      entry: {
        app: ['a.js', 'b.js'],
      },
    }
                        </code></pre>

                        <p></p>


                        <aside class="notes">
                            위의 경우는 a.js랑 b.js가 한 파일로 엮여 app.js라는 결과물로 나옵니다. 이렇게 웹팩은 entry의 js 파일부터 시작해서 import, require 관계로 묶여진 다른 js까지 알아서 파악한 뒤 모두 entry에 기재된 키 개수만큼으로 묶어줍니다.
                        </aside>
                    </section>


                    <section>
                        <h2>output</h2>
                        <p>이제 결과물이 어떻게 나올지 설정을 해야 합니다.</p>

                        <pre><code class="javascript">
    {
      output: {
        path: '/dist',
        filename: '[name].js',
        publicPath: '/',
      },
    }
                        </code></pre>

                        <aside class="notes">
                            path랑 publicPath가 헷갈릴 수 있겠네요. path는 output으로 나올 파일이 저장될 경로입니다. publicPath는 파일들이 위치할 서버 상의 경로입니다. Express에 비유하면 express.static 경로와 비슷한 겁니다. filename을 보시면 좀 이상하게 생긴 게 있습니다. [name].js라고 되어 있는데요. 이렇게 써줘야 [name]에 아까 app이나 zero가 들어가 app.js, zero.js로 결과물이 나옵니다.

다른 옵션으로는 [hash]나 [chunkhash]가 있습니다. [hash]는 매번 웹팩 컴파일 시 랜덤한 문자열을 붙여줍니다. 따라서 캐시 삭제 시 유용합니다. [hash]가 컴파일할 때마다 랜덤 문자열을 붙여준다면 [chunkhash]는 파일이 달라질 때에만 랜덤 값이 바뀝니다. 이것을 사용하면 변경되지 않은 파일들은 계속 캐싱하고 변경된 파일만 새로 불러올 수 있습니다.
                        </aside>
                    </section>



                    <section>
                        <h2>loader</h2>
                        <p>이제부터 막강한 웹팩의 기능들이 나옵니다. 바로 로더(loader)입니다. 보통 웹팩을 사용하면 babel을 주로 같이 사용합니다. ES2015 이상의 문법들은 IE같은 구형 브라우저랑 호환시키기 위함인데요. 또는 jsx같은 react 문법을 컴파일하려고 하는 목적도 있습니다. babel을 웹팩2와 연결시켜 볼까요? 일단 설치부터 해봅니다.</p>

                        <pre><code class="javascript">
    npm i -D babel-loader babel-core babel-preset-es2015 babel-preset-react babel-preset-stage-0
                        </code></pre>

                        <p>일단 babel-loader와 babel-core는 필수이고요. 나머지 preset들은 선택입니다. react는 react 하시는 분만 설치하면 되고요. stage-0은 es2015보다도 더 최신 기술을 위한 겁니다.</p>

                        <pre><code class="javascript">
    {
      module: {
        rules: [{
          test: /\.jsx?$/,
          loader: 'babel-loader',
          options: {
            presets: ['es2015', 'react', 'stage-0'],
          },
          exclude: ['/node_modules'],
        }],
      },
    }
                        </code></pre>

                        <aside class="notes">
혹시 다른 사이트에서 rules나 use 대신 loaders를 쓰고, options 대신 query를 쓰는 곳이 있다면, 웹팩1에 대한 강좌입니다. 웹팩2에서 바뀌었습니다. (물론 하위호환을 위해 여전히 지원하긴 합니다)

위와 같이하면 test 정규식조건(js나 jsx 파일)에 부합하는 파일들을 loader에 지정한 로더가 컴파일해줍니다. options는 로더에 대한 옵션으로 아까 설치한 presets들을 적용하고 있는 게 보입니다. exclude는 제외할 폴더나 파일로, 바벨로 컴파일하지 않을 것들을 지정해줍니다. 바벨로는 컴파일하지 않지만 웹팩으로는 컴파일합니다. 반대로 include로 꼭 이 로더를 사용해서 컴파일할 것들을 지정해줄 수도 있습니다.
                        </aside>
                    </section>


                    <section>
                        <h2>plugin</h2>
                        <p>플러그인은 약간 부가적인 기능입니다. 다양한 플러그인들이 나와있는데 이를 사용하면 효과적으로 번들링을 할 수 있습니다. 예를 들면 압축을 한다거나, 핫리로딩을 한다거나, 파일을 복사하는 등의 부수적인 작업을 할 수 있습니다. 다양한 플러그인들이 패키지로 존재하기 때문에 쇼핑하듯 골라보세요!</p>

                        <pre><code class="javascript">
    {
      plugins: [
        new webpack.LoaderOptionsPlugin({
          minimize: true,
        }),
        new webpack.optimize.UglifyJsPlugin({
          sourceMap: true,
          compress: {
            warnings: true,
          },
        }),
        new webpack.DefinePlugin({
          'process.env.NODE_ENV': 'production',
        }),
      ],
    }
                        </code></pre>

                        <aside class="notes">
                        대표적인 웹팩 기본 제공 플러그인들입니다. LoaderOptionsPlugin은 로더들에게 옵션을 넣어주는 플러그인이고요. UglifyJsPlugin이 압축, console 제거, 소스맵 보존 등을 하는 플러그인이고, DefinePlugin은 JS 변수를 치환해주는 플러그인입니다. 이외에도 BannersPlugin, IgnorePlugin, EnvironmentPlugin, ContextReplacementPlugin 등 기본 제공 플러그인도 어마어마합니다.

웹팩2에서 플러그인들의 변경점이 있습니다. DedupePlugin은 사라졌고, OccurrenceOrderPlugin은 기본으로 켜져 있으니 더 이상 추가하지 마세요.

용량 관계로 다음 강좌에서 계속 이어집니다! 이번 시간에 주로 js를 번들링하는 방법을 살펴봤다면, 다음 시간에는 css랑 기타 파일들 번들링 방법을 알아보겠습니다.
                        </aside>
                    </section>


                    <section>
                        <h2>output</h2>
                        <p>이제 결과물이 어떻게 나올지 설정을 해야 합니다.</p>

                        <pre><code class="javascript">

                        </code></pre>

                        <aside class="notes">
                        </aside>
                    </section>






                </section>











                <section>
                    <h1>감사합니다.</h1>
                </section>
            </div>
        </div>

        <script src="lib/js/head.min.js"></script>
        <script src="js/reveal.js"></script>
        <script>
            // Full list of configuration options available at:
            // https://github.com/hakimel/reveal.js#configuration
            Reveal.initialize({
                controls: true,
                progress: true,
                history: true,
                center: true,

                transition: 'convex', // none/fade/slide/convex/concave/zoom

                // Optional reveal.js plugins
                dependencies: [
                    { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
                    { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                    { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                    { src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
                    { src: 'plugin/zoom-js/zoom.js', async: true },
                    { src: 'plugin/notes/notes.js', async: true }
                ]
            });

            Reveal.addEventListener( 'slidechanged', function(event) {
                // event.previousSlide, event.currentSlide, event.indexh, event.indexv
                var notes = event.currentSlide.querySelector(".notes");
                if(notes) {
                    console.info(notes.innerHTML.replace(/\n\s+/g,'\n'));
                }
            });
        </script>
    </body>
</html>
